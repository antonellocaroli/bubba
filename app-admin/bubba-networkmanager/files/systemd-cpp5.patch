Fix changed behavior in c++11 ABI

Patch by Gordon Bos

--- a/controllers/InterfaceController.cpp
+++ b/controllers/InterfaceController.cpp
@@ -628,11 +628,7 @@
 }
 
 bool InterfaceController::Up(const string& ifname){
-	if (ifname != "br0") {
-		return do_call("/usr/bin/nmcli con up $(/usr/bin/nmcli dev | grep \"^"+ifname+" \" | awk '{print $4}')")==0;
-	}else{
-		return do_call("/usr/bin/nmcli con up $(grep -rl \"br0$\" /etc/NetworkManager/system-connections/ | awk -F/ '{print $NF}')")==0;
-	}
+	return do_call("/usr/bin/nmcli con up $(grep -rl \""+ifname+"$\" /etc/NetworkManager/system-connections/ | awk -F/ '{print $NF}')")==0;
 }
 
 bool InterfaceController::Down(const string& ifname){
--- a/utils/InterfacesCfg.cpp
+++ b/utils/InterfacesCfg.cpp
@@ -165,7 +165,6 @@
 	string curif;
 	string con_name;
 	string uuid;
-	const char* c_uuid;
 
 #if !GLIB_CHECK_VERSION (2, 35, 0)
 	/* Initialize GType system */
@@ -225,8 +224,8 @@
 
 		// WiFi is handled by hostapd and NetworkManager should not intervene
 		if ( (devs.isMember("br0")) && (devs.isMember("wlan0")) && (devs["wlan0"].isMember("UUID")) ){
-			c_uuid = devs["wlan0"]["UUID"].asString().c_str();
-			nm_remote_connection_delete (nm_client_get_connection_by_uuid(client, c_uuid), NULL, NULL);
+			uuid = devs["wlan0"]["UUID"].asString();
+			nm_remote_connection_delete (nm_client_get_connection_by_uuid(client, uuid.c_str()), NULL, NULL);
  			const char* wlmac = nm_device_get_hw_address(nm_client_get_device_by_iface (client, "wlan0"));
 			if (wlmac) {
 				list<string> fil=FileUtils::GetContent(NMCFILE);
@@ -291,24 +290,24 @@
 		// remove br0 connection when switching from br0 to eth1
 		if ( (devs.isMember("br0")) && (devs.isMember("eth1")) && (devs["eth1"].isMember("addressing")) ){
 			if (devs["br0"].isMember("UUID")) {
-				c_uuid = devs["br0"]["UUID"].asString().c_str();
-				nm_remote_connection_delete (nm_client_get_connection_by_uuid(client, c_uuid), NULL, NULL);
+				uuid = devs["br0"]["UUID"].asString();
+				nm_remote_connection_delete (nm_client_get_connection_by_uuid(client, uuid.c_str()), NULL, NULL);
 			}
 			devs.removeMember("br0");
 		}
 
 		// remove eth1 connection whem switching from eth1 to br0
 		if ( (devs.isMember("br0")) && (devs.isMember("eth1")) && (devs["eth1"]["type"]=="bridge-slave") && (devs["eth1"]["con_name"]=="LAN") ){
-			c_uuid = devs["eth1"]["UUID"].asString().c_str();
-			nm_remote_connection_delete (nm_client_get_connection_by_uuid(client, c_uuid), NULL, NULL);
+			uuid = devs["eth1"]["UUID"].asString();
+			nm_remote_connection_delete (nm_client_get_connection_by_uuid(client, uuid.c_str()), NULL, NULL);
 			devs["eth1"].removeMember("UUID");
 		}
 
 		// verify slave connection, delete if invalid
 		if ( (devs.isMember("eth1")) && (devs["eth1"].isMember("master")) ){
 			if ( (!devs.isMember("br0")) || devs["eth1"]["master"].asString() != devs["br0"]["UUID"].asString() ){
-				c_uuid = devs["eth1"]["UUID"].asString().c_str();
-				nm_remote_connection_delete (nm_client_get_connection_by_uuid(client, c_uuid), NULL, NULL);
+				uuid = devs["eth1"]["UUID"].asString();
+				nm_remote_connection_delete (nm_client_get_connection_by_uuid(client, uuid.c_str()), NULL, NULL);
 				devs["eth1"].removeMember("UUID");
 			}
 		}
@@ -429,9 +428,12 @@
 				}
 			}
 
-			c_uuid = devs[*mIt]["UUID"].asString().c_str();
-			connection = (NMConnection*)nm_client_get_connection_by_uuid(client, c_uuid);
-			if ( connection && (s_con = nm_connection_get_setting_connection (connection)) ) {
+			uuid = devs[*mIt]["UUID"].asString();
+			connection = (NMConnection*)nm_client_get_connection_by_uuid(client, uuid.c_str());
+
+			if ( connection == NULL) {
+				cerr << "Error: connection " << uuid << " does not exist\n";
+			} else if ((s_con = nm_connection_get_setting_connection (connection))) {
 				g_object_freeze_notify (G_OBJECT (connection));
 				nm_connection_remove_setting(connection, NM_TYPE_SETTING_IP4_CONFIG);
 				nm_connection_remove_setting(connection, NM_TYPE_SETTING_IP6_CONFIG);
@@ -439,7 +441,7 @@
 				nm_connection_add_setting(connection, (NMSetting*) s_ip6);
 				g_object_thaw_notify (G_OBJECT (connection));
 				if (!nm_remote_connection_commit_changes ((NMRemoteConnection*) connection, TRUE, NULL, &error)) {
-					cerr << "Error updating connection " << c_uuid << " => " << error->message << endl;
+					cerr << "Error updating connection " << uuid << " => " << error->message << endl;
 					g_error_free (error);
 				}
 			}
